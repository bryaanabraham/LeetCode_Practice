You are given an array nums of n integers and two integers k and x.
The x-sum of an array is calculated by the following procedure:
Count the occurrences of all elements in the array.
Keep only the occurrences of the top x most frequent elements. If two elements have the same number of occurrences, the element with the bigger value is considered more frequent.
Calculate the sum of the resulting array.
Note that if an array has less than x distinct elements, its x-sum is the sum of the array.
Return an integer array answer of length n - k + 1 where answer[i] is the x-sum of the subarray nums[i..i + k - 1].

```python
### TLE (Brute Force): Slide accross every possible window, sort values as needed and calculate values for each window.

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        
        iters = len(nums) - k + 1
        sub_sort = []
        for i in range(iters):
            nums_ = nums[i:i+k]
            d = dict()
            for num in nums_:
                if num in d.keys():
                    d[num] += 1
                else:
                    d[num] = 1
        
            sorted_d = sorted(d.items(), key=lambda item: (item[1], item[0]), reverse=True)
            print(sorted_d)
            sub_sort.append(sorted_d)
        
        res = []
        for nums in sub_sort:
            ans = 0
            for i in range(x):
                if len(nums)>i:
                    ans += nums[i][0]*nums[i][1]
                else:
                    break
            res.append(ans)
        return res
```

[Solution:](https://www.youtube.com/watch?v=4GyVDJq3cqg&t=1325s)
- To avoid resorting for every window use a sorted data structure (sorted list or BST).
- We use a sorted list or BST instead of a min/max heap to allow lookup in O(logn) time instead of O(n) time in case of heap.
- create two sorted lists which are figuratively the [:-x] and [-x:] splits of the sorted_d in the above scenario.
- Every time you add to the  "top" sorted list ([:-x]) we update curr_sum
- While updating we only need to check the last value in the bottom list with the value we need to update.

```python
class Solution:
    
    def balance(self):
        if len(self.top)>self.x:
            f, n = self.top.pop(0)
            self.bottom.add((f, n))
            self.curr_sum -= f*n

        if len(self.top)<self.x and self.bottom:
            f, n = self.bottom.pop()
            self.top.add((f, n))
            self.curr_sum += f*n

        if self.top and self.bottom and self.top[0] < self.bottom[-1]:
            f1, n1 = self.top.pop(0)
            f2, n2 = self.bottom.pop()
            self.top.add((f2,n2))
            self.bottom.add((f1,n1))

            self.curr_sum += (f2*n2 - f1*n1)

    def add(self, num):
        if num in self.freq:
            prev = (self.freq[num], num)
            if prev in self.top:
                self.top.remove(prev)
                self.curr_sum -= self.freq[num]*num
            else:
                self.bottom.remove(prev)
        self.freq[num] += 1
        self.top.add((self.freq[num], num))
        self.curr_sum += self.freq[num]*num
        self.balance()

    def rem(self, num):
        if num in self.freq:
            prev = (self.freq[num], num)
            if prev in self.top:
                self.top.remove(prev)
                self.curr_sum -= self.freq[num]*num
            else:
                self.bottom.remove(prev)

        self.freq[num] -= 1
        if self.freq == 0:
            del self.freq[num]
        else:
            self.top.add((self.freq[num], num))
            self.curr_sum += self.freq[num]*num
        self.balance()

    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        self.top = SortedList()
        self.bottom = SortedList()
        self.freq = defaultdict(int)
        self.curr_sum = 0
        self.x = x
        
        res = []
        for i in range(k):
            self.add(nums[i])
        res.append(self.curr_sum)

        for i in range(k, len(nums)):
            self.rem(nums[i-k])
            self.add(nums[i])
            res.append(self.curr_sum)

        return res
```
